package com.cw;

public class ByteIntChange {
    public static void main(String[] args) {

        // 1000 0111 补码
        // 反码是1000 0111-1=1000 0110 负数的补码是反码+1
        // 补码是源码首位不变，其他位按位取反
        // 原码是 1 1111 001  也就是-(1+2^3+2^4+2^5+2^6)=-(1+8+16+32+64)=-121
        String x = "00000111";

        //转int过程 不够32位 左边补了24个0 变成正的了1+2+4+2^7=135
        // 00000000 00000000 00000000 1000 0111
        int int_x = Integer.parseInt(x, 2);
        System.out.println("二进制8位字符串转int，左边补24个0 -->" + int_x);
        // 00000000 00000000 00000000 1000 0111
        // java类型转换是强转 前面24位直接全去掉，得到1000 0111 > -121
        byte y = (byte) int_x;
        System.out.println("从int转回byte-->" + y);
        //int的256是 00000000 00000000 00000001 00000000
        //          10000000 00000000 00000000 01111001 64+32+16+8+1 -121 int 源码
        //          11111111 11111111 11111111 10000110                       反码
        //          11111111 11111111 11111111 10000111                       补码
        //          11111111 11111111 11111111 10000111 1+2+4+128
        //          00000000 00000000 00000001 10000111
        //按位取或，让小于8位的正数变成大于8位，截取后八位
        int y1 = y | 256;//运算的过程 低位向高位强制转换。byte转int直接先转，然后再以补码存
        System.out.println("|256得到的是-->" + y1);
        //将int转二进制字符串，注意这返回的是1开头的，前面如果是0不显示，可能不够8位
        String s1 = Integer.toBinaryString(y1);

        System.out.println("用256凑所以够9位，再截取8位-->" + s1);
    }
}
