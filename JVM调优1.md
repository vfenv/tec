# 1.jvm内存模型

```
类装载子系统、运行时数据区（内存模型）、字节码执行引擎

内存模型：
1-堆、2-方法区（元空间）[常量+静态变量+类信息]     	     共享的
2-栈、4-本地方法栈、5-线程计数器      					 独享的

栈内存放栈帧：一个方法对应的内存空间就是一个方法栈帧。栈帧包含：局部变量、操作数栈、动态链接、方法出口
	
在Java语言里，可作为GC Roots对象的包括如下几种：
1.虚拟机栈(栈桢中的本地变量表)中的引用的对象；
2.方法区中的类静态属性引用的对象；
3.方法区中的常量引用的对象；
4.本地方法栈中JNI的引用的对象；


当发生GC的时候，会从【栈和方法区】上找出所有的GC root，它可能引用了其他成员变量，一直循环下去，直到当前对象不再引用其他成员变量，这一条链条走完了，凡是在这条链条上的对象标记为非垃圾对量，复制到TO区，其他没有指针指向他的，直接删除掉，没有指针指向他的都是垃圾对象，这里涉及到一个复制算法，可达算法

对象还有对象头 OBJECT HEADER，分代年龄里放的分代年龄，和各种锁 偏向锁、轻量锁、重量锁等。

使用javap -c A.class > A.txt 可以对class进行反汇编，可以编译出机器码，机器码含义参考如下：
《JVM指令手册》
aconst_null 将null对象引用压入栈
icounst_m1 将int常量-1压入栈
icounst_1 将int常量1压入栈
lcounst_2 将long常量2压入栈
fcounst_2 将float常量2压入栈
dcounst_2 将double常量2压入栈
bipush 将一个8位带符号的整数压入栈
sipush 将一个16位带符号的整数压入栈
ldc 把常量池中的项压入栈
ldc_w 把常量池中的项压入栈-使用宽索引
ldc2_w 把常量池中long或者double类型的项压入栈-使用宽索引
```



# 2.堆在整个JVM中构成

```
JVM中的堆，一般分为三大部分：新生代、老年代、永久代。

新生代垃圾回收执行Minor GC、老年代垃圾回收执行Major GC.
```



## 2.1.新生代

```
主要是用来存放新生的对象。默认占整个堆的1/3空间。由于频繁创建对象，所以新生代会频繁触发MinorGC进行垃圾回收。

新生代又分为 Eden区、ServivorFrom、ServivorTo三个区。

内存占比是8:1:1，例如jvm分配3G内存，新生代分区1G内存，Eden分800M，S0、S1各100M

Eden区：Java新对象的出生地（如果新创建的对象占用内存很大，则直接分配到老年代）。当Eden区内存不够的时候就会触发MinorGC，对新生代区进行一次垃圾回收。

ServivorTo：保留了一次MinorGC过程中的幸存者。

ServivorFrom：上一次GC的幸存者，作为这一次GC的被扫描者。

当JVM无法为新建对象分配内存空间的时候(Eden满了)，Minor GC被触发。因此新生代空间占用率越高，Minor GC越频繁。
```



## 2.2.新生代的垃圾回收算法《复制算法》

```
新生代回收算法，也就是MinorGC的过程：

1.首先，把Eden和ServivorFrom区域中存活的对象复制到ServivorTo区域（如果有对象的年龄以及达到了老年的标准，一般是15，则复制到老年代区）

2.同时把这些对象的年龄+1（如果ServivorTo不够位置了就放到老年区）

3.然后，清空Eden和ServivorFrom中的对象；最后，ServicorTo和ServicorFrom互换，原ServivorTo成为下一次GC时的ServivorFrom区。

MinorGC通过复制算法 ,回收垃圾，复制算法不会产生内存碎片。

当年轻代满时就会触发Minor GC，这里的年轻代满指的是Eden代满，Survivor满不会引发GC。

复制算法：复制算法将内存划分为两个区间，在任意时间点，所有动态分配的对象都只能分配在其中一个区间（称为活动区间），而另外一个区间（称为空闲区间）则是空闲的

当有效内存空间耗尽时，JVM将暂停程序运行，开启复制算法GC线程。接下来GC线程会将活动区间内的存活对象，全部复制到空闲区间，且严格按照内存地址依次排列，与此同时，GC线程将更新存活对象的内存引用地址指向新的内存地址。

此时，空闲区间已经与活动区间交换，而垃圾对象现在已经全部留在了原来的活动区间，也就是现在的空闲区间。事实上，在活动区间转换为空间区间的同时，垃圾对象已经被一次性全部回收。
```



## 2.3.老年代

```
老年代的对象比较稳定，所以MajorGC不会频繁执行。

在进行MajorGC前一般都先进行了一次MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发。

当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次MajorGC进行垃圾回收腾出空间。
```



## 2.4.老年代垃圾回收算法《标记-清除》

```
MajorGC采用标记—清除算法：

1.首先扫描一次所有老年代，标记出存活的对象

2.然后回收没有标记的对象。

MajorGC的耗时比较长，因为要扫描再回收。MajorGC会产生内存碎片，为了减少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。

当老年代也满了装不下的时候，就会抛出OOM（Out of Memory）异常。

当年老代空间不够用的时候，虚拟机会使用“标记—清除”或者“标记—整理”算法清理出连续的内存空间，分配对象使用。
```



## 2.5.永久代

```
指内存的永久保存区域，主要存放Class和Meta（元数据）的信息。

Class在被加载的时候被放入永久区域。它和和存放实例的区域不同，GC不会在主程序运行期对永久区域进行清理。

所以这也导致了永久代的区域会随着加载的Class的增多而胀满，最终抛出OOM异常。

在Java8中，永久代已经被移除，被一个称为“元数据区”（元空间）的区域所取代。

元空间的本质和永久代类似，都是对JVM规范中方法区的实现。

不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。

类的元数据放入 native memory, 字符串池和类的静态变量放入java堆中. 

这样可以加载多少类的元数据就不再由MaxPermSize控制, 而由系统的实际可用空间来控制。
```



# 3.产生FullGC的原因

## 3.1.Minor GC、Major GC、Full GC的区别

```
Full GC：清理整个堆空间—包括年轻代和老年代叫Full GC,收集young gen、old gen、perm gen（年轻代、老年代和永久代）的垃圾对象。

Major GC：清理Old区(老年代)的垃圾对象叫Major GC,有时又叫old gc，只收集old gen

Minor GC：当清理Eden区和Survivor区(新生代)的垃圾对象叫Minor GC,年轻代满时就会触发Minor GC，这里的年轻代满指的是Eden代满，Survivor满不会引发GC。
```

## 3.2.Full GC触发机制

```
（1）调用System.gc时，系统建议执行Full GC，但是不必然执行
（2）老年代空间不足
（3）方法区空间不足
（4）通过Minor GC后进入老年代的平均大小大于老年代的可用内存
（5）由Eden区、survivorFrom区向survivorTo区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，但老年代的可用内存小于该对象大小

当永久代满时也会引发Full GC，会导致Class、Method元信息的卸载。

老年代满了会先进行Full GC，会对整个堆的所有空间做整体回收。但是发现没用，因为Full GC只会回收没有被引用的，被引用的不能释放。
```

## 3.3.分代年龄计算

```
虚拟机给每个对象定义了一个对象年龄（Age）计数器。
如果对象在 Eden 出生并经过第一次 Minor GC 后仍然存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为 1。
对象在 Survivor 区中每熬过一次 Minor GC，年龄就增加 1 岁，　　当它的年龄增加到一定程度（默认为 15 岁）时，就会被晋升到老年代中。
对象晋升老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold (阈值)来设置。
```

## 3.4.内存分配与回收策略

```
1.对象优先在Eden区进行分配
大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够的空间进行分配时，虚拟机将发起一次MinorGC

2.对象直接进入老年代
所谓大对象就是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串及数组，经常出现大对象容易导致内存还有不少空间时就提前触发垃圾回收以获取足够的连续空间来安置他们。

3.长期存活的对象将进入老年代
虚拟机既然采用了分代收集的思想来管理内存，那内存回收时就必须能识别哪些对象应当放在新生代，哪些对象应放在老年代。为了做到这点，虚拟机给每个对象定义了一个对象年龄计数器。如果对象在Eden出生经过第一次MinorGC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设为1。对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁，当他的年龄增加到一定程度（默认15）时，就会被晋升到老年代中。
对象晋升老年代的年龄阈值，可以通过设置参数-XX:MaxTenuringThreshold。

4 动态对象年龄判定
为了更好地适应不同程序的内存状况，虚拟机并不总是要求对象的年龄必须达到MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。

5 空间分配担保
在发生MinorGC时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小，如果大于，则改为直接进行一次Full GC。如果小于，则查看HandlePromotionFailure设置是否允许担保失败：如果允许，那只会进行MinorGC；如果不允许，则也要改为进行一次FullGC。取平均值进行比较其实仍然是一种动态概率的手段，也就是说如果某次MinorGC存活后的对象突增，远远高于平均值得话，依然会导致担保失败。如果出现了担保失败，那只好在失败后重新发起FullGC。虽然担保失败时绕的圈子是最大的，但大部分情况下还是会将HandlePromotionFailure 开关打开，避免Full GC过于频繁。
```



## 3.5.一个网站频繁FullGC产生的问题以及解决办法

```
堆分配了3个G的内存，在不指定新生代的情况，新生代占据1/3，老年代占2/3的内存。1G新生代，2G老年代
java -Xms3072M -Xmx3072M -Xss1M -XX:MetaspaceSize=512M -jar a.jar

亿级流量1亿，日活500万，买个东西点30次，成单10% 也就是50万订单。
如果3-4小时产生，每秒产生几十个订单  没问题
如果是大促销，每秒产生1000订单，3台机器，也就是每台300单每秒。

订单大小预估：
对象大小估算，int类型占用4个字节，boolean 占用1个字节，字符串根据实际，对象的大小估算就是所有成员变量大小之和，还有对象头等，预估1KB，不会超过1KB。

每个订单假设1KB，每秒300KB订单生成。下单还涉及其它操作，订单，积分，库存等，放大20倍。

每秒6MB的对象产生，在下单时还有其它操作，查询等，再放大10倍=60M，1秒后，这60M失效。

Edon 800M。每秒产生60M,14秒 放满Edon，引发一次MinorGC,其中，前面的可能已经变成垃圾了，但是第14次产生的垃圾60M可能还在被GCroot引用，不能回收。
60M大于S0的100M的一半，不会被放入S0 直接进入老年代，老年代2个G，14秒产生60M，老年代的2G，2048/60=30,14*30=420秒，老年代的2G就用完了，7分钟左右一次FullGC,就会导致系统STW卡住。

一个对象移动到老年代
1.大对象直接进入，大对象就是大连的连续内存空间对象，字符串、数组等。jvm参数 -XX:PretenureSizeTheshold可以设置大对象的大小，超过设置的会直接进入老年代，不会进入年轻代，这个参数只在Serial和ParNew二个收集器下有用。设置-XX:PretenureSizeTheshold=1000000 -XX:+UseSerialGC.

2.长期存活的对象将进入老年代，Age计数器达到15，在survivor中移动一次（或者说经历一次gcroot垃圾清理没被清理掉）分代年龄+1。
  -XX:MaxTenuringThreshold=15 设置分代年龄值

3.对象的动态年龄判断：一批对象总大小 大于这块Survivor区域内存大小的50%，那么大于等于这批对象年龄最大值的对象，就直接进入老年代了。
这个是希望那些可能是长期存活的对象提前进入老年代。
  -XX:TargetSurvivorRatio 设置直接进入老年代的比例

4.Minor GC后，存活的对象Survivor区放不下，这种情况，部分挪到老年代，部分可能还会放在Survivor区

5.老年代空间分配担保机制：每次轻GC之前，都会计算老年代剩余可用空间，如果这个可用空间小于年轻代现有所有对象大小和（包括垃圾对象），就会看一个
-XX:HandlePromotionFailure（1.8是默认设置的），如果有，就会看老年代的可用内存大小是否大于之前每次轻gc进入老年代的对象的平均大小，如果上一步的结果是小于或者之前的参数没设置，那么会触发一次fullgc，如果还没有足够空间存放新对象就会发生OOM。

是否可以让JVM几乎不发生FullGC？可以的，将老年代变小，将年轻代调大就可以了。
java -Xms3072M -Xmx3072M -Xmn2048M -Xss1M -XX:MetaspaceSize=256M -jar a.jar
-Xmn2048M:指定年轻代大小2个G

-Xmx   Java Heap最大值，默认值为物理内存的1/4，最佳设值应该视物理内存大小及计算机内其他内存开销而定；
-Xms   Java Heap初始值，Server端JVM最好将-Xms和-Xmx设为相同值，开发测试机JVM可以保留默认值；
-Xmn   Java Heap Young区大小，不熟悉最好保留默认值；
-Xss   每个线程的Stack大小，不熟悉最好保留默认值；
```



# 4.在JDK1.8中JVM参数设置以及初始堆分配

```
XX:MetaspaceSize=128m (元空间默认大小)
-XX:MaxMetaspaceSize=128m (元空间最大大小)
-Xms1024m (堆最大大小)
-Xmx1024m (堆默认大小)
-Xmn2048m (新生代大小)
-Xss256k (棧最大深度大小)
-XX:SurvivorRatio=8 (新生代分区比例 8:2)
-XX:+UseConcMarkSweepGC (指定使用的垃圾收集器，这里使用CMS收集器)
-XX:+PrintGCDetails (打印详细的GC日志)
JDK8之后把-XX:PermSize 和 -XX:MaxPermGen移除了，取而代之的是
-XX:MetaspaceSize=128m (元空间默认大小)
-XX:MaxMetaspaceSize=128m (元空间最大大小)

JDK 8开始把类的元数据放到本地化的堆内存(native heap)中，这一块区域就叫Metaspace，中文名叫元空间。

使用本地化的内存有什么好处呢？最直接的表现就是java.lang.OutOfMemoryError: PermGen 空间问题将不复存在，因为默认的类的元数据分配只受本地内存大小的限制，也就是说本地内存剩余多少，理论上Metaspace就可以有多大(貌似容量还与操作系统的虚拟内存有关？这里不太清楚)，这解决了空间不足的问题。不过，让Metaspace变得无限大显然是不现实的，因此我们也要限制Metaspace的大小：使用-XX:MaxMetaspaceSize参数来指定Metaspace区域的大小。JVM默认在运行时根据需要动态地设置MaxMetaspaceSize的大小。

默认堆大小：除非在命令行上指定了初始堆大小和最大堆大小，否则它们将根据计算机上的内存量进行计算。

最大物理内存大小不超过192兆字节（MB）时默认最大堆大小是物理内存的一半，否则占用物理内存的四分之一

在32位JVM上，如果有4 GB或更多的物理内存，则默认的最大堆大小最多可以为1 GB。在64位JVM上，如果有128GB或更多的物理内存，则默认的最大堆大小最大为32 GB。

在JVM初始化期间分配了一个较小的值，称为初始堆大小。此数量至少为8 MB，否则为物理内存的1/64，最大为1 GB。

分配给年轻代的最大空间量是堆总大小的三分之一，即年轻代和老年代默认的比例是1:2您可以使用-Xms（初始堆大小）和-Xmx（最大堆大小）来指定初始堆大小和最大堆大小。

如果你知道你的应用程序有多少堆需要工作做好，你可以设置-Xms和-Xmx相同的值。否则，JVM将使用初始堆大小开始，然后将增大Java堆，直到找到堆使用率和性能之间的平衡为止。

以上就是在jdk1.8中的说明，但是在不同jdk版本和使用不同的垃圾收集器后或许会有调整
```

